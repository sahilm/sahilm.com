---
title: Makefiles for Golang
date: 2017/08/20
description: |
  Go's toolchain is awesome. Make makes the toolchain awesome-er.
  Go's fast compile times and internal change-tracking eschews the need
  for esoteric Makefiles. This is great since we can write simple Makefiles
  to get the job done in style.
image: "makefiles-for-golang/fiveyears.jpg"
---

<%= figure('makefiles-for-golang/fiveyears.jpg',
  alt: 'Awesome Gophers',
  caption: 'Awesome Gophers (The Go gopher was designed by Renee French (http://reneefrench.blogspot.com/).
            The design is licensed under the Creative Commons 3.0 Attributions license.)') %>

Go's toolchain is awesome. Make makes the toolchain awesome-er. Go's fast compile times and internal change-tracking
eschews the need for esoteric Makefiles. This is great since we can write simple Makefiles to get the job done in style.

## Quick primer on Make

### Introduction

Make is a build tool from the [70s](https://en.wikipedia.org/wiki/Make_(software)#Origin). Builds are described in files known as Makefiles. Makefiles are composed of rules that look like this:

```makefile
target: prerequisites
	recipe
```

The target is a name of a file. Prerequisites are rules to run _before_ the target/file is built. A recipe describes how
to build the target/file.

The combination of target, its prerequisites and recipe is known as a `rule`. Rules describes how make should rebuild something,
should it need rebuilding. Makes detects changes to targets by tracking the last modified time of its prerequisites. If a prerequisite has changed since the target was last built, the target will be rebuilt. Otherwise Make takes no action and declares the target up-to-date.

Let's know look at a simple example:

```makefile
abc: xyz
	echo "abc" > abc

xyz:
	echo "xyz" > xyz
```

This Makefile declares 2 rules. The target `abc` depends on `xyz` and both of them have recipes that generate their
respective targets. Let's run make for the first time:

```bash
$ make
echo "xyz" > xyz
echo "abc" > abc
```
Notice how I didn't specify which target to build. Make chose the first target as the default. In this case `abc`. We
see that Make runs the prerequisite `xyz` before running `abc`.

Let's try running make again:

```bash
$ make
make: 'abc' is up to date.
```
Make declares that there's nothing to do. The files `xyz` and `abc` already exist. All dependencies have been satisfied
and there is no work to be done. Make's dependency tracking is a powerful feature which we'll exploit in a bit.

Before that, we must understand one last thing. Variables.

### Make Variables


## I don't need no stinkin' Makefile

`go install` automagically checks if the binary is up to date. `go test` is all you need to kick-off tests that run
at face melting speed. Why do I need a Makefile again?

Have you ever felt the need to:

* Communicate to your team how to build the project? Keep this information up to date?
* Sanely install tools and update dependencies in CI?
* Keep the above mentioned tools up to date and add new tools?
* Build Windows, Darwin and Linux binaries in parallel?
* Delete all your build shell scripts and start over?

If you've answered yes to any of the above, Make might be the tool for you.

## What makes Make awesome for Go?

Make makes simple things easy and complex things possible. No scratch that, I was being overtly philosophical. Complex
things are possible but you'll want to gouge your eyes out. Make is hairy, very hairy ðŸ˜€

Luckily, the Go toolchain and Go projects are simple. Simple stuff is fun with Make.

## Baby's first Go Makefile

If you're still reading, I've managed to pique your interest. Hurray! Let's dive into our first task with Make.

<mark>Lint and test the codebase. Oh, and install any tools if they aren't already installed.</mark>

```makefile
.PHONY: check
check: lint test

.PHONY: lint
lint: $(GOMETALINTER)
	gometalinter ./... --vendor

BIN_DIR := $(GOPATH)/bin
GOMETALINTER := $(BIN_DIR)/gometalinter
$(GOMETALINTER):
	go get -u github.com/alecthomas/gometalinter
	gometalinter --install &> /dev/null

PKGS := $(shell go list ./... | grep -v /vendor)
.PHONY: test
test: setup
	go test $(PKGS)
```

Our primary target here is `check`. It first lints and then tests. If linting fails, the build is failed and tests
are never run. We're using [gometalinter](https://github.com/alecthomas/gometalinter) to lint. Notice how `check`
depends on `lint` which further depends on `$(GOMETALINTER)`.

`$(GOMETALINTER)` describes a target which tracks the `gometalinter` binary in our `$GOPATH`. When we run `check` on
a machine that doesn't have `gometalinter`, it'll download and setup `gometalinter`. On subsequent runs of `check`,
nothing is downloaded because the binary is already there.

Essentially, you can run `make check` on any machine, locally or in CI and you're guaranteed to get a build. You can go
ahead and delete all your tool installation scripts.

## Building releases in parallel

```makefile
BINARY := mytool
VERSION ?= latest
PLATFORMS := darwin/amd64 linux/amd64 windows/amd64

temp = $(subst /, ,$@)
os = $(word 1, $(temp))
arch = $(word 2, $(temp))

.PHONY: $(PLATFORMS)
$(PLATFORMS): setup
	mkdir -p $(CURDIR)/release
	GOOS=$(os) GOARCH=$(arch) go build -ldflags="-X main.version=$(VERSION)" \
	-o release/$(BINARY)-v$(VERSION)-$(os)-$(arch)

.PHONY: release
release: $(PLATFORMS)
```

